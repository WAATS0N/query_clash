QUERY CLASH – WEBSITE BUILD INSTRUCTIONS (AGENT SPECIFICATION)
1. Objective

Build a web-based SQL mystery competition platform named Query Clash with the following mandatory characteristics:

Name-based login (no password)

Fail-safe continuation (resume after refresh/crash)

Multiple SQL terminals for exploration

Separate investigation questions with answer verification

Two rounds: Beginner → Intermediate

Only allowed SQL commands (SELECT family)

Winner determined by:

Correct final mystery solution

Least total time taken

The system must be secure, deterministic, and rule-compliant.

2. Technology Constraints (Non-Negotiable)
Backend

Python 3.9+

Flask framework

SQLite database

Frontend

HTML

CSS

Vanilla JavaScript (no frameworks required)

Database Access

SQLite database must be read-only for SQL terminals

Only backend can verify answers

3. High-Level Architecture
Browser
 ├── Name Entry Page
 ├── Game Interface
 │     ├── Multiple SQL Terminals
 │     ├── Investigation Panel
 │     └── Timer Display
 └── Submission Page
        ↓
Flask Backend
 ├── Name-Based Session Manager
 ├── Fail-Safe Timer Engine
 ├── SQL Query Validator & Executor
 ├── Investigation Verifier
 └── Progress Controller
        ↓
SQLite Database

4. Project Structure (Must Follow Exactly)
query_clash/
│
├── app.py
├── database.db
│
├── templates/
│   ├── index.html        # Name entry
│   ├── game.html         # Main gameplay UI
│   └── submit.html       # Final submission
│
├── static/
│   ├── style.css
│   └── script.js
│
└── README.md

5. Database Specification
5.1 Core Tables

Create these tables exactly as defined:

participants (
  name TEXT PRIMARY KEY,
  current_round INTEGER,
  round_start_time DATETIME,
  elapsed_time INTEGER,
  solved INTEGER
);

investigations (
  id INTEGER PRIMARY KEY,
  round INTEGER,
  prompt TEXT,
  correct_answer TEXT
);

investigation_progress (
  name TEXT,
  investigation_id INTEGER,
  solved INTEGER
);

submissions (
  name TEXT,
  round INTEGER,
  final_answer TEXT,
  submission_time DATETIME,
  time_taken INTEGER
);

5.2 Mystery Data Tables

Create multiple read-only tables such as:

suspects

crime_reports

interviews

locations

phone_logs

Populate them before the event.

6. Name-Based Login (Fail-Safe Identity)
Required Behavior

User enters name only

Backend checks:

If name exists → load progress

If not → create new participant row

Name is the only identifier

Constraints

No passwords

No emails

No client-side state authority

7. Fail-Safe Timer System
Required Properties

Timer is server-side authoritative

Timer:

Starts when round is first accessed

Continues across refresh/crash

Saves elapsed time on every action

Calculation Rule
remaining_time = round_limit - elapsed_time


Frontend timer is display-only.

8. Multi-SQL Terminal System
Functional Requirements

Provide multiple SQL terminals (UI-level separation)

Each terminal allows:

Writing SQL

Executing allowed queries

Viewing independent results

Backend Rules

All terminals use the same SQLite database

Terminals do NOT submit answers

Queries are logged optionally (not required)

9. SQL Command Enforcement (Critical)
Allowed

SELECT

WHERE

ORDER BY

LIMIT

JOIN

GROUP BY

HAVING

Subqueries

Aggregate functions

Blocked (Must Reject)

INSERT

UPDATE

DELETE

DROP

ALTER

PRAGMA

ATTACH

TRANSACTION commands

Enforcement Location

Backend only

Never rely on frontend validation

10. Investigation Module
Definition

An investigation is a question-based checkpoint.

Each investigation:

Displays a prompt

Accepts a plain-text answer

Is verified server-side

Unlocks progression

Rules

SQL queries cannot be submitted as answers

Answer verification is case-insensitive

Correct answers are never sent to frontend

11. Round Logic
Round 1 – Beginner

Multiple investigations

Must solve all to unlock Round 2

Round 2 – Intermediate

Final investigation

Determines mystery solution

Direct URL access to Round 2 must be blocked unless Round 1 is completed.

12. Final Submission Logic

One-time submission per participant

Backend validates final answer

Records:

Completion time

Correctness

Locks participant state after submission

13. Winner Determination Logic

Rank participants by:

Correct final solution

Least total elapsed time

Organizer may review logs if required.

14. Frontend UI Requirements
Mandatory UI Elements

Participant name (read-only)

Current round indicator

Timer

SQL terminal tabs

Investigation panel

Answer input & submit button

Clear success/failure feedback

UI must prevent:

Multiple submissions

Editing name mid-event

15. Security & Fairness Constraints

Database opened in read-only mode for SQL execution

No client-side authority over:

Timer

Round access

Verification

All enforcement is server-side

16. Deployment Requirements
Local Network Mode (Preferred)

Single host machine

Participants access via browser

No internet required

Cloud Mode (Optional)

Stable hosting

Limited concurrency if needed

17. Testing Requirements (Mandatory)

Agent must test:

Page refresh recovery

Crash recovery

SQL injection attempts

Invalid SQL rejection

Tie conditions

Direct URL abuse

18. Completion Criteria

The build is considered complete only if:

Participants can resume after failure

Multiple SQL terminals work independently

Investigations verify answers correctly

Winner ranking is deterministic

Rules are enforced without manual intervention

19. Non-Functional Requirements

Code must be readable

Logic must be deterministic

No unused authentication code

No external dependencies beyond Flask

20. Final Note to Agent

This system is competition-critical.
Favor clarity, enforcement, and correctness over visual complexity.